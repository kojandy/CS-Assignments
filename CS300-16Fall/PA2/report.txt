# 알고리즘 설명

알고리즘은 기본적으로 수업시간에 배운 다익스트라 알고리즘을 기반으로 작성하였다. 교과서에 나와있는 방법은 우선순위 큐를 이용하는 방법이나, 이 문제에서는 그래프가 인접행렬을 이용하여 나타내어져 있으므로 그래프의 데이터를 읽는데에만 **O(V^2)**의 시간이 걸린다고 보아 우선순위 큐를 사용하지 않고 배열에 나타내어 선형시간에 최소인 원소를 찾도록 프로그램을 작성하였다. 자세한 각 함수의 루틴에 대한 설명은 아래 시간복잡도를 계산하는 과정에서 같이 설명하도록 하겠다.

# 시간복잡도 계산

## `find_s_path`의 시간복잡도

- 6: `map_initialize()`는 변수를 초기화 하는 함수이므로 **O(1)**
- 8, 9: **O(1)**
- 10, 11: `cities`에서 `departure`, `destination`과 같은 문자열의 index를 찾아 저장하는 과정이다. **O(V)**
- 13~16: 각종 변수의 초기화 과정이다. **O(V)**
- 17~: `while q`는 총 정점의 개수만큼 돌게 된다.
- 18~23: `q`는 최솟값을 찾게 될 원소들의 **set**이다. `d`는 `q`에 들어 있는 원소들에 부여된 값으로 `q`에 들어있는 원소 `i`에 대해서 `d[i]`의 값이 최소인 것을 찾는 것이다. 이는 그냥 `q`에 들어있는 모든 원소에 대하여 검사를 하므로 `q`에 들어있는 원소의 수만큼의 연산을 하게 된다. 그러므로 이 부분의 시간복잡도는 **O(V)**가 된다. **O(V^2)**
- 24: 위에서 찾은 최소의 거리를 갖는 원소를 제거하는 과정이다. **O(V^2)**
- 25~26: 만약 찾은 `u`가 우리가 찾고자하는 경로의 도착점이라면 그 즉시 지금까지의 결과를 return한다. **O(V)**
- 27~: 찾은 `u`에 대하여 인접한(간선에 의해 연결되어 있는) 정점 모두를 탐색하면서 relaxation을 하는 과정이다. 그래프가 인접행렬의 꼴로 표현되어 있으므로 간선을 알아내기 위해서는 정점의 수만큼 반복하여 찾아야 한다.
- 28: 정점 `v`에 대하여 `u`와 연결이 되어있는지 확인한 후 새로 찾은 간선으로 정점 `v`를 방문하면 더 거리가 짧은지 확인하는 분기점이다. **O(V^2)**
- 29~31: 위의 조건을 만족하는 정점 `v`에 대하여 새로 찾은 경로를 저장하고 거리를 저장하는 과정이다. **O(V^2)**

위의 분석을 통해 우리는 `find_s_path`의 시간복잡도가 **O(V^2)**임을 알 수 있다.